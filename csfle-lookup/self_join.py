"""
Experimenting with self join.
"""

import os
from pymongo import MongoClient
from pprint import pprint

print("Connecting to Atlas...")

PASSWORD = os.getenv("JOEL_ATLAS_PWD")
if PASSWORD is None:
    raise Exception("Password not set in environment.")
MONGO_URI = f"mongodb+srv://joelodom:{PASSWORD}@joelqecluster.udwxc.mongodb.net/?retryWrites=true&w=majority&appName=JoelQECluster"

DB_NAME = "self_join_experiment"
COLLECTION_NAME = "employees"

client = MongoClient(MONGO_URI, auto_encryption_opts=None)
db = client[DB_NAME]
collection = db[COLLECTION_NAME]

print("(Re-)creating database...")

if DB_NAME in client.list_database_names():
    client.drop_database(DB_NAME)

collection.insert_many([
  {
    "_id": 1,
    "name": "Alice",
    "position": "CEO",
    "manager_id": None
  },
  {
    "_id": 2,
    "name": "Bob",
    "position": "CTO",
    "manager_id": 1
  },
  {
    "_id": 3,
    "name": "Charlie",
    "position": "CFO",
    "manager_id": 1
  },
  {
    "_id": 4,
    "name": "David",
    "position": "Engineer",
    "manager_id": 2
  },
  {
    "_id": 5,
    "name": "Eve",
    "position": "Engineer",
    "manager_id": 2
  },
  {
    "_id": 6,
    "name": "Frank",
    "position": "Accountant",
    "manager_id": 3
  }
])

print("Trying a self-join with a subpipeline...")

pipeline = [
    {
        "$lookup": {
            "from": "employees",
            "localField": "manager_id",
            "foreignField": "_id",
            "as": "manager_info",
            "pipeline": [
                {
                    "$match": { "position": "CTO" }
                }
            ]
        }
    },

    # At this point every record in the collection now has a manager_info
    # document on it, generated by the sub-pipeline. The records that don't
    # match in the subpipeline are [], whereas the ones that do match are
    # an array of all of the documents that match. If I comment out the pipeline
    # then the only difference is that every document in the pipeline has a
    # filled-out manager_info array. So I think the way this works is that the
    # $lookup always adds a new sub-collection to the document that is the
    # join for all matches, and the sub-pipeline can be used to manage details
    # about the sub-collections that are added in the lookup.

    # {
    #     "$unwind": {
    #         "path": "$manager_info",
    #         "preserveNullAndEmptyArrays": True
    #     }
    # },
    # {
    #     "$project": {
    #         "employee_name": "$name",
    #         "manager_name": "$manager_info.name",
    #         "manager_position": "$manager_info.position",
    #         "manager_id": "$manager_id"
    #     }
    # }
]

results = collection.aggregate(pipeline)

print("Results:")
for result in results:
    pprint(result)
